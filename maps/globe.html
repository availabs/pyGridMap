
<!DOCTYPE html>
<html>
<head>
	<title>Grid Map</title>
	<meta charset="utf-8" />

	<link rel="stylesheet" href="styles/globe.css" />
</head>
<body>

	<div id="display">
		<svg id="map" class="fill-screen" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
		<canvas id="animation" class="fill-screen"></canvas>
		<canvas id="overlay" class="fill-screen"></canvas>
		<svg id="foreground" class="fill-screen" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
	</div>

	<script src="bower_components/underscore/underscore.js"></script>
	<script src="bower_components/d3/d3.js"></script>
	<script src="bower_components/topojson/topojson.js"></script>

	<script src="js/d3.geo/d3.geo.projection.v0.min.js" charset="utf-8"></script>
	<script src="js/d3.geo/d3.geo.polyhedron.v0.min.js" charset="utf-8"></script>

	<script src="js/earth/micro.js"></script>
	<script src="js/earth/globes.js"></script>
	<script src="js/src/colorGrids.js"></script>
	<script src="js/src/canvasDisplay.js"></script>
	
	<script>

	var op = null;
	var	view = getView();

	d3.json('data/earth-topo.json',function(err,topo){

		// Specify mobile device settings later
		// Figure out where 'mesh' is defined in earth.js
		var o = topo.objects;
		var coastLo = topojson.feature(topo, o.coastline_110m);
		var coastHi = topojson.feature(topo, o.coastline_50m);
		var lakesLo = topojson.feature(topo, o.lakes_110m);
		var lakesHi = topojson.feature(topo, o.lakes_50m);

		function newOp(startMouse, startScale) {
			return {
				type: "click",  // initially assumed to be a click operation
				startMouse: startMouse,
				startScale: startScale,
				manipulator: globe.manipulator(startMouse, startScale)
			};
		}

		var zoom = d3.behavior.zoom()
			.scale(350) // Must be the same as the last number in the globe.orientation() string
			.on("zoomstart", function() {
				op = op || newOp(d3.mouse(this), zoom.scale());  // a new operation begins
				// Render lo-res coastlines and lakes
				coastline.datum(coastLo);
				lakes.datum(lakesLo);
				console.log('zoom')
				console.log('op', op);
				canvasDisplay.hide();
			})
			.on("zoom", function() {
				var currentMouse = d3.mouse(this), currentScale = d3.event.scale;
				//console.log()
				op = op || newOp(currentMouse, 1);  // Fix bug on some browsers where zoomstart fires out of order.
				if (op.type === "click" || op.type === "spurious") {
					var distanceMoved = distance(currentMouse, op.startMouse);
					if (currentScale === op.startScale && distanceMoved < 4) {
						// to reduce annoyance, ignore op if mouse has barely moved and no zoom is occurring
						op.type = distanceMoved > 0 ? "click" : "spurious";
						return;
					}
					//dispatch.trigger("moveStart");
					doDraw_throttled()
					//op.type = "drag";
				}
				if (currentScale != op.startScale) {
					op.type = "zoom";  // whenever a scale change is detected, (stickily) switch to a zoom operation
				}

				// when zooming, ignore whatever the mouse is doing--really cleans up behavior on touch devices
				op.manipulator.move(op.type === "zoom" ? null : currentMouse, currentScale);
				//console.log('zoom2',op.type === "zoom" ? null : currentMouse, currentScale);
				doDraw_throttled();
			})
			.on("zoomend", function() {
				op.manipulator.end();
				// Render hi-res coastlines and lakes
				coastline.datum(coastHi);
				lakes.datum(lakesHi);
				d3.selectAll("path").attr("d", path);
				if (op.type === "click") {
					//dispatch.trigger("click", op.startMouse, globe.projection.invert(op.startMouse) || []);
				}
				else if (op.type !== "spurious") {
					//signalEnd();
				}
				canvasDisplay.update(globe);
				op = null;  // the drag/zoom/click operation is over
			});

		d3.select("#display").call(zoom);

		var coastData = topojson.feature(topo, topo.objects.coastline_50m);
		var lakeData = topojson.feature(topo, topo.objects.lakes_50m);
		var configuration = {};
		var projectionName = 'orthographic'
		//atlantis
		//azimuthal_equidistant
		//conic_equidistant
		//equirectangular
		//orthographic
		//stereographic
		//waterman
		//winkel3

		var globe = globes.get(projectionName)(view);
		globe.defineMap(d3.select("#map"), d3.select("#foreground"));
		zoom.scaleExtent(globe.scaleExtent()); // Confines scale of globe
		globe.orientation('-60, 0, 350',view); // Sets initial globe position
		console.log('the globe object',globe.orientation())

		var path = d3.geo.path().projection(globe.projection).pointRadius(7);
		var coastline = d3.select(".coastline");
		var lakes = d3.select(".lakes");
		var grids = d3.select(".colorGrids");
		//colorGrids.draw(grids,path)
		//canvasDisplay.animateGrids(globe)
		//canvasDisplay.drawGrids(globe)
		canvasDisplay.drawHeights(globe)

		//---- activate the canvas!
		var width = view.width, height = view.height;
        var canvas = d3.select(document.createElement("canvas")).attr("width", width).attr("height", height).node();
        var context = globe.defineMask(canvas.getContext("2d"));
        context.fillStyle = "rgba(255, 0, 0, 1)";
        context.fill();
        // d3.select("#display").node().appendChild(canvas);  // make mask visible for debugging

        var imageData = context.getImageData(0, 0, width, height);
        var data = imageData.data;  // layout: [r, g, b, a, r, g, b, a, ...]

        d3.selectAll(".fill-screen").attr("width", view.width).attr("height", view.height);
			coastline.datum(coastData);
			lakes.datum(lakeData);

		d3.selectAll("path").attr("d", path)

		// Throttled draw method helps with slow devices that would get overwhelmed by too many redraw events.
		var REDRAW_WAIT = 15;  // milliseconds
		var doDraw_throttled = _.throttle(doDraw, REDRAW_WAIT, {leading: false});

		function doDraw() {
			//console.log('draw')
			d3.selectAll("path").attr("d", path);
			//rendererAgent.trigger("redraw");
			doDraw_throttled = _.throttle(doDraw, REDRAW_WAIT, {leading: false});
		}
	})

	function getView() {
		var w = window;
		var d = document && document.documentElement;
		var b = document && document.getElementsByTagName("body")[0];
		var x = w.innerWidth || d.clientWidth || b.clientWidth;
		var y = w.innerHeight || d.clientHeight || b.clientHeight;
		return {width: x, height: y};
	}

	function distance(a, b) {
		var Δx = b[0] - a[0];
		var Δy = b[1] - a[1];
		return Math.sqrt(Δx * Δx + Δy * Δy);
	}

	function createMask(globe) {
        if (!globe) return null;

        console.time("render mask");

        // Create a detached canvas, ask the model to define the mask polygon, then fill with an opaque color.
        var width = view.width, height = view.height;
        var canvas = d3.select(document.createElement("canvas")).attr("width", width).attr("height", height).node();
        var context = globe.defineMask(canvas.getContext("2d"));
        context.fillStyle = "rgba(255, 0, 0, 1)";
        context.fill();
        // d3.select("#display").node().appendChild(canvas);  // make mask visible for debugging

        var imageData = context.getImageData(0, 0, width, height);
        var data = imageData.data;  // layout: [r, g, b, a, r, g, b, a, ...]
        console.timeEnd("render mask");
        return {
            imageData: imageData,
            isVisible: function(x, y) {
                var i = (y * width + x) * 4;
                return data[i + 3] > 0;  // non-zero alpha means pixel is visible
            },
            set: function(x, y, rgba) {
                var i = (y * width + x) * 4;
                data[i    ] = rgba[0];
                data[i + 1] = rgba[1];
                data[i + 2] = rgba[2];
                data[i + 3] = rgba[3];
                return this;
            }
        };
    }

	</script>

</body>
</html>
