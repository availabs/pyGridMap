
<!DOCTYPE html>
<html>
<head>
	<title>Grid Map</title>
	<meta charset="utf-8" />


	<link rel="stylesheet" href="styles/globe.css" />
</head>
<body>

	<div id="display">
        <svg id="map" class="fill-screen" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
        <canvas id="animation" class="fill-screen"></canvas>
        <canvas id="overlay" class="fill-screen"></canvas>
        <svg id="foreground" class="fill-screen" xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
    </div>

    <script src="bower_components/underscore/underscore.js"></script>
	<script src="bower_components/d3/d3.js"></script>
	<script src="bower_components/topojson/topojson.js"></script>

	<script src="js/d3.geo/d3.geo.projection.v0.min.js" charset="utf-8"></script>
    <script src="js/d3.geo/d3.geo.polyhedron.v0.min.js" charset="utf-8"></script>

	<script src="js/earth/globes.js"></script>
	<script>
	var op = null,
		view = getView();

    d3.json('data/earth-topo.json',function(err,topo){

		// Specify mobile device settings later
		// Figure out where 'mesh' is defined in earth.js
		var o = topo.objects;
		var coastLo = topojson.feature(topo, o.coastline_110m);
		var coastHi = topojson.feature(topo, o.coastline_50m);
		var lakesLo = topojson.feature(topo, o.lakes_110m);
		var lakesHi = topojson.feature(topo, o.lakes_50m);

		// console.log('topo', coastHi)

		function newOp(startMouse, startScale) {
	        return {
	            type: "click",  // initially assumed to be a click operation
	            startMouse: startMouse,
	            startScale: startScale,
	            manipulator: globe.manipulator(startMouse, startScale)
	        };
	    }

		var zoom = d3.behavior.zoom()
			.scale(150)
	        .on("zoomstart", function() {
	            op = op || newOp(d3.mouse(this), zoom.scale());  // a new operation begins
				// Render lo-res coastlines and lakes
				coastline.datum(coastLo);
				lakes.datum(lakesLo);
	            console.log('zoom')
	        })
	        .on("zoom", function() {
	            var currentMouse = d3.mouse(this), currentScale = d3.event.scale;
	            //console.log()
	            op = op || newOp(currentMouse, 1);  // Fix bug on some browsers where zoomstart fires out of order.
	            if (op.type === "click" || op.type === "spurious") {
	                var distanceMoved = distance(currentMouse, op.startMouse);
	                if (currentScale === op.startScale && distanceMoved < 4) {
	                    // to reduce annoyance, ignore op if mouse has barely moved and no zoom is occurring
	                    op.type = distanceMoved > 0 ? "click" : "spurious";
	                    return;
	                }
	                //dispatch.trigger("moveStart");
	                doDraw_throttled()
	                //op.type = "drag";
	            }
	            if (currentScale != op.startScale) {
	                op.type = "zoom";  // whenever a scale change is detected, (stickily) switch to a zoom operation
	            }

	            // when zooming, ignore whatever the mouse is doing--really cleans up behavior on touch devices
				op.manipulator.move(op.type === "zoom" ? null : currentMouse, currentScale);
	            console.log('zoom2',op.type === "zoom" ? null : currentMouse, currentScale)
	            doDraw_throttled()
	        })
	        .on("zoomend", function() {
	            op.manipulator.end();
				// Render hi-res coastlines and lakes
				coastline.datum(coastHi);
				lakes.datum(lakesHi);
				d3.selectAll("path").attr("d", path);
	            if (op.type === "click") {
	                //dispatch.trigger("click", op.startMouse, globe.projection.invert(op.startMouse) || []);
	            }
	            else if (op.type !== "spurious") {
	                //signalEnd();
	            }
	            op = null;  // the drag/zoom/click operation is over
	        });

	    d3.select("#display").call(zoom);

		var coastData = topojson.feature(topo, topo.objects.coastline_50m);
		var lakeData = topojson.feature(topo, topo.objects.lakes_50m);
		var projectionName = 'winkel3'
		//atlantis
		//azimuthal_equidistant
		//conic_equidistant
		//equirectangular
		//orthographic
		//stereographic
		//waterman
		//winkel3

		var globe = globes.get(projectionName)(view);
			globe.defineMap(d3.select("#map"), d3.select("#foreground"));
			globe.orientation(globe.orientation(),view)
			console.log('the globe object',globe.orientation())

		var path = d3.geo.path().projection(globe.projection).pointRadius(7);
	    var coastline = d3.select(".coastline");
	    var lakes = d3.select(".lakes");
	    d3.selectAll(".fill-screen").attr("width", view.width).attr("height", view.height);
		coastline.datum(coastData);
		lakes.datum(lakeData);

		d3.selectAll("path").attr("d", path);

		// Throttled draw method helps with slow devices that would get overwhelmed by too many redraw events.
        var REDRAW_WAIT = 5;  // milliseconds
        var doDraw_throttled = _.throttle(doDraw, REDRAW_WAIT, {leading: false});

		function doDraw() {
	        console.log('draw')
	        d3.selectAll("path").attr("d", path);
	        //rendererAgent.trigger("redraw");
	        doDraw_throttled = _.throttle(doDraw, REDRAW_WAIT, {leading: false});
    	}
	})

	function getView() {
        var w = window;
        var d = document && document.documentElement;
        var b = document && document.getElementsByTagName("body")[0];
        var x = w.innerWidth || d.clientWidth || b.clientWidth;
        var y = w.innerHeight || d.clientHeight || b.clientHeight;
        return {width: x, height: y};
    }

    function distance(a, b) {
        var Δx = b[0] - a[0];
        var Δy = b[1] - a[1];
        return Math.sqrt(Δx * Δx + Δy * Δy);
    }

	</script>

</body>
</html>
